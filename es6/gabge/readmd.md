# 垃圾回收

在 JavaScript 中，垃圾回收（Garbage Collection, GC）是一种自动内存管理机制，用于检测和清除不再使用的对象，释放其占用的内存空间，以防止内存泄漏并提升程序性能。以下从多个关键方面介绍：
一、垃圾回收的核心概念
活动对象：当前仍被程序引用的对象，不会被回收。
垃圾对象：不再被任何活动对象引用的对象，其占用的内存可被回收。例如函数执行完毕后，内部创建的局部变量若不再被引用，就可能成为垃圾对象。
二、垃圾回收算法
引用计数算法
原理：为每个对象维护一个引用计数器，有新引用时计数器加 1，引用失效时减 1，计数为 0 则回收对象。
优点：算法简单，能实时回收垃圾对象，减少内存占用。
缺点：无法处理循环引用（如两个对象相互引用且无外部引用，计数永不为 0），导致内存泄漏；频繁更新计数器会增加开销。实际中现代 JS 引擎很少单独使用此算法。
标记 - 清除算法
标记阶段：从根对象（如浏览器中的 window、Node.js 中的 global、当前函数活动栈帧中的局部变量等）出发，遍历所有可达对象，标记为 “活动”。
清除阶段：遍历内存，清除未标记的对象（即垃圾对象），回收其内存。
优点：能解决循环引用问题，是现代 JS 引擎（如 V8）的基础算法。
缺点：执行时会暂停 JS 代码（垃圾回收停顿），堆中对象多时影响性能；回收后可能产生内存碎片，降低后续内存分配效率。
三、垃圾回收的根集合（GC Roots）
垃圾回收从 “根集合” 开始查找活动对象，包括：
全局对象（浏览器 window，Node.js global）；
当前函数的活动栈帧（局部变量）；
全局作用域中引用的变量；
DOM 节点及其他全局对象。
只有从根集合可达的对象才是活动对象，不会被回收。
四、垃圾回收的触发机制
内存使用量达到阈值：堆内存中对象占用超过一定比例，触发垃圾回收释放内存。
手动触发：部分引擎提供手动触发方式（如 V8 引擎的 gc()，但需启用开发者模式，且不推荐在生产环境随意使用，因可能影响性能）。
事件循环：某些引擎会在事件循环空闲时间触发垃圾回收。
五、垃圾回收的优化策略
减少全局变量：全局变量生命周期长，不易回收，尽量少用。
避免循环引用：使用 WeakMap 或 WeakSet（弱引用，不影响对象垃圾回收）避免不必要的强引用循环。
手动解除引用：对象不再使用时，及时设为 null，如 let obj = { a: 1 }; obj = null;（通知引擎可回收）。
控制变量作用域：将变量限制在最小作用域内，如用块级作用域 {}，使变量尽早释放。
六、内存泄漏与调试
内存泄漏场景：
未清理的事件监听器（绑定后未解绑，处理器持续引用）；
闭包不合理引用外部变量，导致变量无法回收；
DOM 元素引用未清除（如保存了对 DOM 元素的引用，即使元素从文档移除，内存仍被占用）。
调试方法：利用浏览器开发者工具（如 Chrome DevTools 的 Memory 面板）进行堆快照分析，定位内存增长异常的原因。
七、现代引擎的优化（以 V8 为例）
分代回收：将堆内存分为新生代（存放短周期对象，如临时变量，用复制算法快速回收）和老生代（存长周期对象，如全局变量，用标记 - 整理 - 清除算法，减少碎片）。
增量回收：将垃圾回收拆分为小步骤，穿插在程序执行中，减少长时间停顿对用户体验的影响。
惰性回收：内存紧张时才执行回收，优化高负载下的程序性能。